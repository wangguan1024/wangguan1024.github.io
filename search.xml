<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Excel读写操作及Pyinstaller打包exe</title>
    <url>/2020/10/24/Python/Excel%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E5%8F%8APyinstaller%E6%89%93%E5%8C%85exe/</url>
    <content><![CDATA[<blockquote>
<p>“1024”程序员节快乐！</p>
</blockquote>
<span id="more"></span>

<h2 id="项目中用到的第三方库"><a href="#项目中用到的第三方库" class="headerlink" title="项目中用到的第三方库"></a>项目中用到的第三方库</h2><ul>
<li>xlrd</li>
<li>xlwt</li>
<li>pyinstaller<br>经测试，使用conda均可安装。</li>
</ul>
<h3 id="导入相关依赖"><a href="#导入相关依赖" class="headerlink" title="导入相关依赖"></a>导入相关依赖</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>

<h3 id="获得windows桌面路径"><a href="#获得windows桌面路径" class="headerlink" title="获得windows桌面路径"></a>获得windows桌面路径</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获得桌面路径</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_desk_p</span>():</span></span><br><span class="line">    <span class="keyword">return</span> os.path.join(os.path.expanduser(<span class="string">&#x27;~&#x27;</span>),<span class="string">&quot;Desktop&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="xlrd-代码示例"><a href="#xlrd-代码示例" class="headerlink" title="xlrd 代码示例"></a>xlrd 代码示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#原始数据文件模型</span></span><br><span class="line">   desktop_path = os.path.join(get_desk_p(), FILE_NAME)</span><br><span class="line">   source_xlsx = xlrd.open_workbook(desktop_path)</span><br><span class="line">   source_sheet = source_xlsx.sheet_by_name(SHEET_NAME)</span><br><span class="line"></span><br><span class="line">   <span class="comment">#获取总行数</span></span><br><span class="line">   rows_length = source_sheet.nrows</span><br><span class="line">   <span class="comment">#字典形式存放原始数据，key为订单编号，value为该订单的商品</span></span><br><span class="line">   cache_dict = &#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows_length):</span><br><span class="line">       row_value = source_sheet.row_values(i)</span><br><span class="line">       order_number = row_value[<span class="number">0</span>]</span><br><span class="line">       <span class="keyword">if</span>(order_number <span class="keyword">in</span> cache_dict):</span><br><span class="line">           cache_dict[order_number].append(row_value[<span class="number">1</span>])</span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           cache_dict[order_number] = [row_value[<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">   <span class="comment">#处理原始数据，去掉只有一种商品的订单</span></span><br><span class="line">   <span class="comment">#获取字典的keys的列表</span></span><br><span class="line">   keys_list = <span class="built_in">list</span>(cache_dict.keys())</span><br></pre></td></tr></table></figure>
<h3 id="xlwt-代码示例"><a href="#xlwt-代码示例" class="headerlink" title="xlwt 代码示例"></a>xlwt 代码示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数据写入excel</span></span><br><span class="line">    output_xlsx = xlwt.Workbook(encoding= <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    output_sheet = output_xlsx.add_sheet(<span class="string">&#x27;output&#x27;</span>)</span><br><span class="line">    <span class="comment">#第0行为表头，第0列对应第一列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#调整宽度</span></span><br><span class="line">    output_sheet.col(<span class="number">0</span>).width=<span class="number">5000</span></span><br><span class="line">    output_sheet.col(<span class="number">1</span>).width=<span class="number">15000</span></span><br><span class="line">    output_sheet.col(<span class="number">2</span>).width=<span class="number">8000</span></span><br><span class="line">    output_sheet.col(<span class="number">3</span>).width=<span class="number">8000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#输出表头</span></span><br><span class="line">    result = result_list[<span class="number">0</span>]</span><br><span class="line">    field_num = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> result.keys():</span><br><span class="line">        output_sheet.write(<span class="number">0</span>, field_num, label=key)<span class="comment">#(row, col, data)</span></span><br><span class="line">        field_num += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#输出数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(result_list)):</span><br><span class="line">        result = result_list[i]</span><br><span class="line">        field_num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> result.keys():</span><br><span class="line">            output_sheet.write(i+<span class="number">1</span>, field_num, label=result[key])<span class="comment">#(row, col, data)</span></span><br><span class="line">            field_num+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(GET_ALL_DATA):</span><br><span class="line">        output_path = os.path.join(get_desk_p(), <span class="string">&#x27;output_all.xls&#x27;</span>)</span><br><span class="line">        output_xlsx.save(output_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        output_path = os.path.join(get_desk_p(), <span class="string">&#x27;output.xls&#x27;</span>)</span><br><span class="line">        output_xlsx.save(output_path)</span><br></pre></td></tr></table></figure>

<h2 id="pyinstaller的使用"><a href="#pyinstaller的使用" class="headerlink" title="pyinstaller的使用"></a>pyinstaller的使用</h2><p><code>conda install pyinstaller</code><br><strong>注：</strong>若在conda虚拟环境使用，需要通过anaconda prompt切换到对应虚拟环境终端进行下面操作，使用cmd会找不到pyinstaller依赖</p>
<ol>
<li>切换到当前文件的工作目录</li>
<li>执行命令<code>pyinstaller -F -w &lt;*.py&gt;</code></li>
</ol>
<p>-F 参数意味着 dist目录下只有单个可执行文件<br>-w 隐藏命令行窗口的黑框，减少用户内心的阴影面积<br>加上-F参数，生成的.exe文件在本次项目中移动到其他目录下，也可执行</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>本地notebook切换anaconda虚拟环境</title>
    <url>/2021/01/06/Python/%E6%9C%AC%E5%9C%B0notebook%E5%88%87%E6%8D%A2anaconda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<ol>
<li>首先打开Anaconda Prompt命令行</li>
<li>切换至目标anaconda虚拟环境，安装ipykernel组件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate &lt;子环境名称&gt;</span><br><span class="line">conda install ipykernel</span><br></pre></td></tr></table></figure></li>
<li>启动jupyter notebook，在jupyter里面手动切换至对应子环境即可</li>
</ol>
<p>推荐一下vscode自带的notebook编辑环境，开发非常方便。vscode yyds~</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>RestController返回时间日期格式化</title>
    <url>/2020/06/12/SpringBoot/RestController%E8%BF%94%E5%9B%9E%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<p>SpringBoot的RestController默认采用jackson进行对象到json的序列化，因此需要在项目配置文件中修改相关配置以进行对于日期时间（Data数据类型）的格式化。</p>
<p>此处以YAML格式配置文件为例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="comment">#参数意义：</span></span><br><span class="line">    <span class="comment">#JsonInclude.Include.ALWAYS       默认</span></span><br><span class="line">    <span class="comment">#JsonInclude.Include.NON_DEFAULT   属性为默认值不序列化</span></span><br><span class="line">    <span class="comment">#JsonInclude.Include.NON_EMPTY     属性为 空（””） 或者为 NULL 都不序列化</span></span><br><span class="line">    <span class="comment">#JsonInclude.Include.NON_NULL      属性为NULL  不序列化</span></span><br><span class="line">    <span class="attr">default-property-inclusion:</span> <span class="string">ALWAYS</span></span><br><span class="line">    <span class="attr">time-zone:</span> <span class="string">GMT+8</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title>YAML语法学习记录</title>
    <url>/2020/04/06/SpringBoot/YAML%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h2><p>k: v 表示一对键值对（空格必须有）</p>
<p>以空格的缩进控制层级关系（类比python，左对齐同一层级）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">	<span class="attr">path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure>

<p>对属性和值大小写敏感</p>
<h2 id="2、各类值的写法"><a href="#2、各类值的写法" class="headerlink" title="2、各类值的写法"></a>2、各类值的写法</h2><h3 id="字面量：-普通的值（数字、字符串、布尔）"><a href="#字面量：-普通的值（数字、字符串、布尔）" class="headerlink" title="字面量： 普通的值（数字、字符串、布尔）"></a>字面量： 普通的值（数字、字符串、布尔）</h3><p>k: v 字面直接写</p>
<p>字符串默认不用加单双引号</p>
<p><strong>“ “ : 双引号不会转义特殊字符</strong></p>
<p><strong>‘ ‘ : 单引号将特殊字符默认转义</strong></p>
<h3 id="对象、map：（键值对）"><a href="#对象、map：（键值对）" class="headerlink" title="对象、map：（键值对）"></a>对象、map：（键值对）</h3><p>k：v</p>
<p>对象还是k：v键值对的方式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正常写法</span></span><br><span class="line"><span class="attr">friends:</span></span><br><span class="line">	<span class="attr">lastName:</span> <span class="string">wangguan</span></span><br><span class="line">	<span class="attr">age:</span> <span class="number">20</span></span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">friends:</span> &#123;<span class="attr">lastName:</span> <span class="string">wangguan</span>, <span class="attr">age:</span> <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组（List、Set）"><a href="#数组（List、Set）" class="headerlink" title="数组（List、Set）"></a>数组（List、Set）</h3><p>用-值表示数组中的一个元素</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正常写法</span></span><br><span class="line"><span class="attr">pets:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">pig</span></span><br><span class="line"><span class="comment"># 行内写法</span></span><br><span class="line"><span class="attr">pets:</span> [<span class="string">cat</span>, <span class="string">dog</span>, <span class="string">pig</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title>Vue.config.js配置跨域及全局scss样式</title>
    <url>/2021/03/10/Vue/Vue.config.js%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F%E5%8F%8A%E5%85%A8%E5%B1%80scss%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<ol>
<li><p>在前后端分离的web应用的开发阶段，解决跨域问题一直让很多开发者头痛。在开发环境中解决思路要么是后端设置跨域，要么是前端设置代理。基于vue-cli的开发中，内置的webpack-dev-server具有代理功能，可以在前端解决跨域问题。</p>
</li>
<li><p>scss作为element ui采用的css预处理器，在使用element ui的基础上自定义样式方面具有更好的兼容性。在开发安卓时全局样式（如字体、颜色）的集中管理体现出很好的优越性，于是我尝试在前端css的开发中也使用类似的方式，将字符串或颜色统一集中管理，主要也是在vue.config.js进行配置。</p>
</li>
</ol>
<span id="more"></span>

<p>直接参考下列配置代码。<br>注意更改完配置要手动npm run serve重新启动服务</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vue跨域配置</span></span><br><span class="line"><span class="keyword">let</span> proxyObj = &#123;</span><br><span class="line">    <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        target: <span class="string">&quot;https://xxxxx.com&quot;</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        https: <span class="literal">false</span>,</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">            <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        cookieDomainRewrite: &#123; <span class="string">&#x27;xxxxx.com&#x27;</span>: <span class="string">&#x27;localhost&#x27;</span>, &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//vue dev服务器配置</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        host: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">        port: <span class="number">8080</span>,</span><br><span class="line">        proxy: proxyObj</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//关闭生产环境下源码查看</span></span><br><span class="line">    productionSourceMap:<span class="literal">false</span>,</span><br><span class="line">    <span class="comment">//scss全局样式文件配置</span></span><br><span class="line">    css: &#123;</span><br><span class="line">        loaderOptions: &#123;</span><br><span class="line">            scss: &#123;</span><br><span class="line">              <span class="comment">// 根据自己样式文件的位置调整</span></span><br><span class="line">              prependData: <span class="string">`@import &quot;~@/assets/style/global.scss&quot;;`</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        config</span><br><span class="line">          .plugin(<span class="string">&#x27;html&#x27;</span>)</span><br><span class="line">          .tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">            args[<span class="number">0</span>].title= <span class="string">&#x27;填些网站标题&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> args</span><br><span class="line">          &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>Vue设置环境变量区别应用开发环境和生产环境</title>
    <url>/2021/05/03/Vue/Vue%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%8C%BA%E5%88%AB%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>vue开发中，经常需要配置一些全局环境变量，比如ajax请求的BASE_URL等等，采取硬编码的方式不仅不优雅而且易出错，尤其是在开发环境和生产模式不断切换之下。</p>
<p>vue提供了模式(mode)和环境变量配置(.env.[mode])相关功能，当执行npm run serve时mode为development，当执行npm run build则会切换mode为production。</p>
<p>因此只要通过配置不同的环境变量配置文件(.env.[mode])，就可以在不同环境下采用不同的全局环境变量而不会出错。</p>
<span id="more"></span>

<ol>
<li>在<strong>项目根目录</strong>下创建.env.[mode]文件，如 .env.production .env.development</li>
<li>编辑.env内容格式为<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[key]&#x3D;[value]</span><br></pre></td></tr></table></figure></li>
<li>代码示例<br>/.env.development (开发环境配置)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NODE_ENV&#x3D;development</span><br><span class="line">VUE_APP_URL&#x3D;http:&#x2F;&#x2F;localhost:8080&#x2F;api</span><br><span class="line">VUE_APP_WSURL&#x3D;ws:&#x2F;&#x2F;localhost:9000&#x2F;ws</span><br></pre></td></tr></table></figure></li>
</ol>
<p>/.env.production (生产环境配置)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NODE_ENV&#x3D;production</span><br><span class="line">VUE_APP_URL&#x3D;https:&#x2F;&#x2F;www.example.com&#x2F;api</span><br><span class="line">VUE_APP_WSURL&#x3D;wss:&#x2F;&#x2F;www.example.com&#x2F;ws</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title>nginx常用命令及生产环境配置跨域和https</title>
    <url>/2020/07/03/Web%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F%E5%92%8Chttps/</url>
    <content><![CDATA[<p>主要内容为：</p>
<ol>
<li>nginx常用命令汇总</li>
<li>踩坑/经验分享</li>
<li>https配置示例，包括wss配置</li>
<li>http配置示例</li>
</ol>
<span id="more"></span>

<h1 id="nginx常用命令"><a href="#nginx常用命令" class="headerlink" title="nginx常用命令"></a>nginx常用命令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx  #打开 nginx</span><br><span class="line">nginx -t     #测试配置文件是否有语法错误</span><br><span class="line">nginx -s reopen  #重启Nginx</span><br><span class="line">nginx -s reload    #重新加载Nginx配置文件，然后以优雅的方式重启Nginx</span><br><span class="line">nginx -s stop   #强制停止Nginx服务</span><br><span class="line">nginx -s quit   #优雅地停止Nginx服务（即处理完所有请求后再停止服务）</span><br></pre></td></tr></table></figure>

<h1 id="经验分享"><a href="#经验分享" class="headerlink" title="经验分享"></a>经验分享</h1><ol>
<li><p>proxy_pass配置，消除路由前缀</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;api &#123; </span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;;</span><br><span class="line">        &#125;</span><br><span class="line">        #访问&#x2F;api&#x2F;test 路由至http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;test</span><br><span class="line">location &#x2F;api &#123; </span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line">        #访问&#x2F;api&#x2F;test 路由至http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;api&#x2F;test</span><br></pre></td></tr></table></figure></li>
<li><p>调试环境去掉nginx缓存，方便调试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;&#123;</span><br><span class="line">            add_header Cache-Control no-cache;</span><br><span class="line">            add_header Pragma no-cache;</span><br><span class="line">            add_header Expires 0;</span><br><span class="line">            index index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>websocket wss配置<br>nginx路由配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ^~&#x2F;ws &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:9000;</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">            proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>客户端访问url</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;wss://www.example.com/ws&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> stomp = Stomp.over(socket);</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="https配置示例"><a href="#https配置示例" class="headerlink" title="https配置示例"></a>https配置示例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl; #配置HTTPS的默认访问端口号为443。此处如果未配置HTTPS的默认访问端口，可能会造成Nginx无法启动。Nginx 1.15.0以上版本请使用listen 443 ssl代替listen 443和ssl on。</span><br><span class="line">        server_name www.example.com; #将www.certificatestests.com修改为您证书绑定的域名，例如：www.example.com。如果您购买的是通配符域名证书，要修改为通配符域名，例如：*.aliyun.com。</span><br><span class="line"></span><br><span class="line">        ssl_certificate cert&#x2F;4806111_www.example.com.pem;  #将domain name.pem替换成您证书的文件名称。</span><br><span class="line">        ssl_certificate_key cert&#x2F;4806111_www.example.com.key; #将domain name.key替换成您证书的密钥文件名称。</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        root &#x2F;root&#x2F;javaweb&#x2F;static&#x2F;;</span><br><span class="line"></span><br><span class="line">        location ^~&#x2F;api&#x2F; &#123; </span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ^~&#x2F;ws &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">            proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 适配vue-router history模式</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"># http重定向 </span><br><span class="line">server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  www.example.com;</span><br><span class="line">        </span><br><span class="line">        rewrite ^(.*)$ https:&#x2F;&#x2F;$host$1 permanent;   #将所有HTTP请求通过rewrite重定向到HTTPS。</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="http配置示例"><a href="#http配置示例" class="headerlink" title="http配置示例"></a>http配置示例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        listen       [::]:80 default_server;</span><br><span class="line">        server_name  www.example.com;</span><br><span class="line">        # root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line"></span><br><span class="line">        location ^~&#x2F;api&#x2F; &#123; </span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location &#x2F;&#123;</span><br><span class="line">            root &#x2F;root&#x2F;javaweb&#x2F;static&#x2F;;</span><br><span class="line">            index index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 &#x2F;404.html;</span><br><span class="line">            location &#x3D; &#x2F;40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line">            location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web应用部署</category>
      </categories>
  </entry>
  <entry>
    <title>Git常用命令整理</title>
    <url>/2020/03/04/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="本地Git基本操作"><a href="#本地Git基本操作" class="headerlink" title="本地Git基本操作"></a>本地Git基本操作</h1><h2 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h2><p><code>git init</code> </p>
<h2 id="管理工作区"><a href="#管理工作区" class="headerlink" title="管理工作区"></a>管理工作区</h2><p>工作区即项目目录，文件可以直接读写</p>
<p><code>git status</code><br>打印仓库当前的状态，显示有变更的文件</p>
<p><code>git diff</code><br>比较工作区和暂存区文件的差异</p>
<p><code>git checkout -- &lt;file&gt;</code><br>该命令可以丢弃工作区的更改，回到最近一次<code>git commit</code>或<code>git add</code>的状态，本质上就是用版本库的文件替换工作区的文件<code>--</code>很重要，没有的话该命令功能为“切换另一个分支”</p>
<h2 id="管理暂存区-staging-area"><a href="#管理暂存区-staging-area" class="headerlink" title="管理暂存区(staging area)"></a>管理暂存区(staging area)</h2><p>暂存区即git内部的cache，暂时存储当前更改</p>
<p><code>git add &lt;file&gt;</code><br>添加文件到暂存区</p>
<p><code>git reset HEAD &lt;file&gt;</code><br>把暂存区的修改撤销，重新放回工作区<br>注：<code>git reset</code>  命令既可以回退版本，也可以把暂存区的修改回退到工作区，HEAD表示当前版本</p>
<h2 id="管理版本"><a href="#管理版本" class="headerlink" title="管理版本"></a>管理版本</h2><p><code>git commit -m &lt;message&gt;</code><br>提交当前暂存区所有更改到当前分支</p>
<p><code>git log </code><br>查看历史提交信息， <code>git log -1</code>查看上一次提交信息</p>
<p><code>git reset HEAD/HEAD^/&lt;commit_id&gt;</code><br>根据HEAD指针或者git log打印的commit_id回退版本</p>
<p><code>git revert HEAD/HEAD^/&lt;commit_id&gt;</code><br>revert命令会讲本次撤销操作作为一次最新的提交<br>注： HEAD表示当前版本，HEAD^表示上一个版本，HEAD^^表示上上一个，HEAD~100表示往上100个版本。git reset –hard 表示代码发生改变</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><code>git branch</code><br>查看所有分支</p>
<p><code>git branch dev</code><br>新增分支dev</p>
<p><code>git switch dev</code>或者<code>git checkout dev</code>(不推荐，有歧义)<br>切换分支</p>
<p><code>git merge dev</code><br>切换到主分支后，使用此命令将dev分支合并到主分支</p>
<p><code>git branch -d dev</code><br>删除dev分支</p>
<h1 id="与远程版本库协作"><a href="#与远程版本库协作" class="headerlink" title="与远程版本库协作"></a>与远程版本库协作</h1><p><em>首先要在github个人设置里面配置本机ssh key</em></p>
<p><code>git remote add origin git@github.com:&lt;github_username&gt;/&lt;github_repo&gt;</code><br>将远程库对应的本地名称设置为origin，将本地当前仓库与<github_username>账号的<github_repo>仓库关联</p>
<p><code>git remote rm origin</code><br>删除本地origin远程库，实质上是解除了本地库与远程库的绑定关系，远程库没有改动</p>
<p><code>git clone &lt;url&gt;</code><br>从仓库下载到本地</p>
<p><code>git push origin &lt;branch&gt;:&lt;远程分支名&gt; </code><br>将本地<branch>上的修改提交到远程指定分支，若缺省&lt;远程分支名&gt;，则提交至与本地分支名称相同的远程分支</p>
<p><code>git fetch origin &lt;branch&gt;</code><br>执行完这个命令后，同步下来的代码不会自动合并到分支上，而是存放到origin/master分支上，之后可以通过<code>git diff</code> 和<code>git merge</code>来手动进行合并</p>
<p><code>git pull origin &lt;branch&gt;</code><br>该命令相当于将fetch和merge放在一起执行</p>
]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA中Maven提示dependency not found</title>
    <url>/2021/04/06/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/IDEA%E4%B8%ADMaven%E6%8F%90%E7%A4%BAdependency%20not%20found/</url>
    <content><![CDATA[<p>解决方法：idea中菜单栏File -&gt;invalidate Caches /Restart，选择Invalidate and Restart, 清除缓存重启ide即可</p>
]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL相关经验教训</title>
    <url>/2020/03/15/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/MySQL%E7%9B%B8%E5%85%B3%E7%BB%8F%E9%AA%8C%E6%95%99%E8%AE%AD/</url>
    <content><![CDATA[<p>MySQL数据库命名规范，不要使用-短横线，应当使用_下划线，否则执行某些语句时会引发异常。</p>
]]></content>
      <categories>
        <category>开发经验</category>
      </categories>
  </entry>
  <entry>
    <title>AOP面向切面编程</title>
    <url>/2020/03/30/SpringBoot/%E6%A6%82%E5%BF%B5/AOP%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a>基本概念介绍</h1><h2 id="和IoC-DI的联系和区别"><a href="#和IoC-DI的联系和区别" class="headerlink" title="和IoC/DI的联系和区别"></a>和IoC/DI的联系和区别</h2><p>如果说依赖注入（DI，Dependency Injection）有助于应用对象之间的解耦，那么面向切面编程（AOP，Aspect Oriented Programing）则有助于横切关注点与它们所影响的对象之间的解耦。</p>
<h2 id="详细定义"><a href="#详细定义" class="headerlink" title="详细定义"></a>详细定义</h2><p>AOP（Aspect Oriented Programing）：<br>面向切面编程，将通用的逻辑从业务逻辑中分离出来。AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离”。</p>
<h2 id="相关概念与名词解释"><a href="#相关概念与名词解释" class="headerlink" title="相关概念与名词解释"></a>相关概念与名词解释</h2><h3 id="1-连接点（Joinpoint）"><a href="#1-连接点（Joinpoint）" class="headerlink" title="1. 连接点（Joinpoint）"></a>1. 连接点（Joinpoint）</h3><p>表示需要在程序中插入横切关注点的扩展点，连接点可能是类初始化、方法执行、方法调用、字段调用或处理异常等等，Spring只支持方法执行连接点；在AOP中表示为“在哪里干”；</p>
<h3 id="2-切入点（Pointcut）"><a href="#2-切入点（Pointcut）" class="headerlink" title="2. 切入点（Pointcut）"></a>2. 切入点（Pointcut）</h3><p>选择一组相关连接点的模式，即可以认为连接点的集合，Spring支持perl5正则表达式和AspectJ切入点模式，Spring默认使用AspectJ语法；在AOP中表示为“在哪里干的集合”；</p>
<h3 id="3-通知（Advice）"><a href="#3-通知（Advice）" class="headerlink" title="3. 通知（Advice）"></a>3. 通知（Advice）</h3><p>在连接点上执行的行为，通知提供了在AOP中需要在切入点所选择的连接点处进行扩展现有行为的手段；包括前置通知（before advice）、后置通知(after advice)、环绕通知（around advice），在Spring中通过代理模式实现AOP，并通过拦截器模式以环绕连接点的拦截器链织入通知；在AOP中表示为“干什么”；</p>
<h3 id="4-切面（Aspect）"><a href="#4-切面（Aspect）" class="headerlink" title="4. 切面（Aspect）"></a>4. 切面（Aspect）</h3><p>横切关注点的模块化，比如日志组件。可以认为是通知、引入和切入点的组合；在Spring中可以使用Schema和@AspectJ方式进行组织实现；在AOP中表示为“在哪干和干什么集合”；</p>
<h3 id="5-引入（Introduction）"><a href="#5-引入（Introduction）" class="headerlink" title="5. 引入（Introduction）"></a>5. 引入（Introduction）</h3><p>也称为内部类型声明，为已有的类添加额外新的字段或方法，Spring允许引入新的接口（必须对应一个实现）到所有被代理对象（目标对象）；在AOP中表示为“干什么（引入什么）”；</p>
<h3 id="6-目标对象（Target-Object）"><a href="#6-目标对象（Target-Object）" class="headerlink" title="6. 目标对象（Target Object）"></a>6. 目标对象（Target Object）</h3><p>需要被织入横切关注点的对象，即该对象是切入点选择的对象，需要被通知的对象，从而也可称为“被通知对象”；由于Spring AOP 通过代理模式实现，从而这个对象永远是被代理对象；在AOP中表示为“对谁干”；</p>
<h3 id="7-AOP代理（AOP-Proxy）"><a href="#7-AOP代理（AOP-Proxy）" class="headerlink" title="7. AOP代理（AOP Proxy）"></a>7. AOP代理（AOP Proxy）</h3><p>AOP框架使用代理模式创建的对象，从而实现在连接点处插入通知（即应用切面），就是通过代理来对目标对象应用切面。在Spring中，AOP代理可以用JDK动态代理或CGLIB代理实现，而通过拦截器模型应用切面。</p>
<h3 id="8-织入（Weaving）"><a href="#8-织入（Weaving）" class="headerlink" title="8. 织入（Weaving）"></a>8. 织入（Weaving）</h3><p>织入是一个过程，是将切面应用到目标对象从而创建出AOP代理对象的过程，织入可以在编译期、类装载期、运行期进行。组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</p>
<h1 id="SpringBoot配置示例"><a href="#SpringBoot配置示例" class="headerlink" title="SpringBoot配置示例"></a>SpringBoot配置示例</h1><ol>
<li>maven引入依赖<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>创建Aspect切面类<br>注意Aspect注解和Component注解都不能少，pointcut注解后面需要定义一个空的方法。<br>通过JoinPoint可以获得通知的签名信息，如目标方法名、目标方法参数信息等。通过RequestContextHolder来获取请求信息，Session信息。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.demo.service.impl.UserServiceImpl.printUser(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是前置通知!!!&quot;</span>);</span><br><span class="line">        <span class="comment">//获取目标方法的参数信息</span></span><br><span class="line">        Object[] obj = joinPoint.getArgs();</span><br><span class="line">        <span class="comment">//AOP代理类的信息</span></span><br><span class="line">        joinPoint.getThis();</span><br><span class="line">        <span class="comment">//代理的目标对象</span></span><br><span class="line">        joinPoint.getTarget();</span><br><span class="line">        <span class="comment">//用的最多 通知的签名</span></span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        <span class="comment">//代理的是哪一个方法</span></span><br><span class="line">        System.out.println(signature.getName());</span><br><span class="line">        <span class="comment">//AOP代理类的名字</span></span><br><span class="line">        System.out.println(signature.getDeclaringTypeName());</span><br><span class="line">        <span class="comment">//AOP代理类的类（class）信息</span></span><br><span class="line">        signature.getDeclaringType();</span><br><span class="line">        <span class="comment">//获取RequestAttributes</span></span><br><span class="line">        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="comment">//从获取RequestAttributes中获取HttpServletRequest的信息</span></span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) requestAttributes.resolveReference(RequestAttributes.REFERENCE_REQUEST);</span><br><span class="line">        <span class="comment">//如果要获取Session信息的话，可以这样写：</span></span><br><span class="line">        <span class="comment">//HttpSession session = (HttpSession) requestAttributes.resolveReference(RequestAttributes.REFERENCE_SESSION);</span></span><br><span class="line">        Enumeration&lt;String&gt; enumeration = request.getParameterNames();</span><br><span class="line">        Map&lt;String,String&gt; parameterMap = Maps.newHashMap();</span><br><span class="line">        <span class="keyword">while</span> (enumeration.hasMoreElements())&#123;</span><br><span class="line">            String parameter = enumeration.nextElement();</span><br><span class="line">            parameterMap.put(parameter,request.getParameter(parameter));</span><br><span class="line">        &#125;</span><br><span class="line">        String str = JSON.toJSONString(parameterMap);</span><br><span class="line">        <span class="keyword">if</span>(obj.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请求的参数信息为：&quot;</span>+str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>概念</category>
      </categories>
  </entry>
  <entry>
    <title>IoC控制反转</title>
    <url>/2020/03/29/SpringBoot/%E6%A6%82%E5%BF%B5/IoC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="IoC控制反转（IoC，Inversion-of-Control）"><a href="#IoC控制反转（IoC，Inversion-of-Control）" class="headerlink" title="IoC控制反转（IoC，Inversion of Control）"></a>IoC控制反转（IoC，Inversion of Control）</h2><p>IoC是一个概念，是一种思想。控制反转就是对象控制权的转移，从程序代码本身反转到了外部容器。把对象的创建、初始化、销毁等工作交给spring容器来做。由spring容器控制对象的生命周期。也就是将new 的过程交给spring容器去处理。</p>
<h2 id="DI依赖注入（Dependency-Injection）"><a href="#DI依赖注入（Dependency-Injection）" class="headerlink" title="DI依赖注入（Dependency Injection）"></a>DI依赖注入（Dependency Injection）</h2><p>依赖注入DI是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。依赖注入是目前最优秀的解耦方式。依赖注入让Spring的Bean之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。</p>
<h2 id="IoC和DI的联系与区别"><a href="#IoC和DI的联系与区别" class="headerlink" title="IoC和DI的联系与区别"></a>IoC和DI的联系与区别</h2><p>IoC是目的，DI是手段。IoC是指让生成类的方式由传统方式（new）反转过来，即程序员不调用new，需要类的时候由框架注入（DI），是对同一件事不同层面的解读。</p>
<p>《EXPERT ONE ON ONE J2EE DEVELOPMENT WITHOUT EJB》第6章<br>IoC主要的实现方式有两种：依赖查找，依赖注入。(128页)<br>依赖注入是一种更可取的方式。(130页)</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>概念</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot组件管理@Component和@Bean的理解</title>
    <url>/2020/04/29/SpringBoot/%E6%A6%82%E5%BF%B5/SpringBoot%E7%BB%84%E4%BB%B6%E7%AE%A1%E7%90%86@Component%E5%92%8C@Bean%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Bean和-Configuration组件管理"><a href="#Bean和-Configuration组件管理" class="headerlink" title="@Bean和@Configuration组件管理"></a>@Bean和@Configuration组件管理</h2><p>SpringBoot推荐容器中组件管理采用全注解的方式</p>
<p>配置类相当于Spring配置文件</p>
<p>比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wangguan.yamlconfig.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.wangguan.yamlconfig.bean.Dog;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Bean与-Component两种组件管理方式的区别"><a href="#Bean与-Component两种组件管理方式的区别" class="headerlink" title="@Bean与@Component两种组件管理方式的区别"></a>@Bean与@Component两种组件管理方式的区别</h2><p>@Component 作用就相当于 XML配置，并没有显式创建组件对象，而是“声明式”的标注组件，更符合SpringBoot的风格。</p>
<p>@Service @Repository等注解为@Component的子集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;lkm&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Bean 需要在配置类中使用，即类上需要加上@Configuration注解。在配置类的同名方法中添加@Bean注解，并显式手动创建组件对象，作为同名方法的返回值，示例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种方式配置的组件，在需要注入的地方都可以通过@Autowired装配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Student student;</span><br></pre></td></tr></table></figure>

<h3 id="那为什么有了-Component-还需要-Bean呢？"><a href="#那为什么有了-Component-还需要-Bean呢？" class="headerlink" title="那为什么有了@Component,还需要@Bean呢？"></a>那为什么有了@Component,还需要@Bean呢？</h3><p>如果想要将第三方库中的组件装配到你的应用中，在这种情况下，不方便或无法修改源码，是没有办法在它的类上添加@Component注解的，因此就不能使用声明式自动化装配的方案了。但是我们可以在配置类种使用@Bean，通过调用构造函数手动创建对象再return的方式将组件引入应用容器。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>概念</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatisPlus分页插件配置</title>
    <url>/2020/05/25/SpringBoot/%E9%85%8D%E7%BD%AE/MyBatisPlus%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<ol>
<li>新建MyBatisPlusConfig.java，和同名配置类</li>
<li>配置类中编写如下代码<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.demo.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title">mybatisPlusInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MybatisPlusInterceptor interceptor = <span class="keyword">new</span> MybatisPlusInterceptor();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> PaginationInnerInterceptor(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConfigurationCustomizer <span class="title">configurationCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> configuration -&gt; configuration.setUseDeprecatedExecutor(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>配置</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatisPlus连接MySQL配置</title>
    <url>/2020/05/25/SpringBoot/%E9%85%8D%E7%BD%AE/MyBatisPlus%E8%BF%9E%E6%8E%A5MySQL%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>SpringBoot-MyBatisPlus连接MySQL数据库配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/&lt;dbname&gt;?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">&lt;password&gt;</span></span><br><span class="line">    <span class="comment"># 以下为可选配置</span></span><br><span class="line">    <span class="attr">hikari:</span></span><br><span class="line">      <span class="comment"># 连接池名</span></span><br><span class="line">      <span class="attr">pool-name:</span> <span class="string">DateHikariCP</span></span><br><span class="line">      <span class="comment"># 最小空闲连接数</span></span><br><span class="line">      <span class="attr">minimum-idle:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment"># 空闲连接存活最大时间，默认600000 （10分钟）</span></span><br><span class="line">      <span class="attr">idle-timeout:</span> <span class="number">180000</span></span><br><span class="line">      <span class="comment"># 最大连接数， 默认10</span></span><br><span class="line">      <span class="attr">maximum-pool-size:</span> <span class="number">10</span></span><br><span class="line">      <span class="comment"># 从连接池返回的连接自动提交</span></span><br><span class="line">      <span class="attr">auto-commit:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 连接最大存活时间，0表示永久存活，默认1800000（30分钟）</span></span><br><span class="line">      <span class="attr">max-lifetime:</span> <span class="number">1800000</span></span><br><span class="line">      <span class="comment"># 连接超时时间，默认30000（30秒）</span></span><br><span class="line">      <span class="attr">connection-timeout:</span> <span class="number">30000</span></span><br><span class="line">      <span class="comment"># 测试连接是否可用的查询语句</span></span><br><span class="line">      <span class="attr">connection-test-query:</span> <span class="string">SELECT</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>配置</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot后端配置跨域</title>
    <url>/2020/06/15/SpringBoot/%E9%85%8D%E7%BD%AE/SpringBoot%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="1-配置类中实现WebMvcConfigurer接口重写addCorsMappings方法"><a href="#1-配置类中实现WebMvcConfigurer接口重写addCorsMappings方法" class="headerlink" title="1. 配置类中实现WebMvcConfigurer接口重写addCorsMappings方法"></a>1. 配置类中实现WebMvcConfigurer接口重写addCorsMappings方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;http://localhost:8080&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;PUT&quot;</span>,<span class="string">&quot;DELETE&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>)</span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-添加CorsConfigurationSource-Bean配置跨域"><a href="#2-添加CorsConfigurationSource-Bean配置跨域" class="headerlink" title="2. 添加CorsConfigurationSource Bean配置跨域"></a>2. 添加CorsConfigurationSource Bean配置跨域</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function">CorsConfigurationSource <span class="title">corsConfigurationSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        CorsConfiguration configuration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        configuration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        configuration.setAllowedOriginPatterns(Collections.singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowedMethods(Collections.singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowedHeaders(Collections.singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setMaxAge(Duration.ofHours(<span class="number">1</span>));</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,configuration);</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="若配置跨域后浏览器控制台"><a href="#若配置跨域后浏览器控制台" class="headerlink" title="若配置跨域后浏览器控制台"></a>若配置跨域后浏览器控制台</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest cannot load localhost:4201&#x2F;ticker. Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.</span><br></pre></td></tr></table></figure>
<p>检查前端请求url是否忘写http或者https<br>Any time you see that “only supported for protocol schemes” message, it almost certainly means you’ve just forgotten to put the https or http on the request URL in your code.</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>配置</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot开发环境生产环境多配置实现</title>
    <url>/2020/04/13/SpringBoot/%E9%85%8D%E7%BD%AE/SpringBoot%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%A4%9A%E9%85%8D%E7%BD%AE%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="profile多环境支持，实现开发环境与生产环境的分离"><a href="#profile多环境支持，实现开发环境与生产环境的分离" class="headerlink" title="profile多环境支持，实现开发环境与生产环境的分离"></a>profile多环境支持，实现开发环境与生产环境的分离</h2><h3 id="1、多配置文件yml、properties"><a href="#1、多配置文件yml、properties" class="headerlink" title="1、多配置文件yml、properties"></a>1、多配置文件yml、properties</h3><p>比如：</p>
<p>/resouces</p>
<p>​    - application.yml</p>
<p>​    - application-dev.yml</p>
<p>​    - application-prod.yml</p>
<p>默认使用application.yml</p>
<p>可以在application.yml中激活其他文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>

<h3 id="2、yml多文档块"><a href="#2、yml多文档块" class="headerlink" title="2、yml多文档块"></a>2、yml多文档块</h3><p>/resouces/application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure>

<h3 id="3、相关命令"><a href="#3、相关命令" class="headerlink" title="3、相关命令"></a>3、相关命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar *.jar --spring.profiles.active=dev</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringBoot</category>
        <category>配置</category>
      </categories>
  </entry>
  <entry>
    <title>js基础知识复习1——变量</title>
    <url>/2021/05/09/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A01%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="es6中与变量相关的各类知识点"><a href="#es6中与变量相关的各类知识点" class="headerlink" title="es6中与变量相关的各类知识点"></a>es6中与变量相关的各类知识点</h1><h2 id="let-和-var的区别"><a href="#let-和-var的区别" class="headerlink" title="let 和 var的区别"></a>let 和 var的区别</h2><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>如果你编写一个声明并初始化变量的多行 JavaScript 程序，你可以在初始化一个变量之后再用 var 声明它，它仍然可以工作。但是提升操作并不能适用于let，这是一件好事，因为先初始化后声明会让代码混乱。</p>
<h3 id="多次声明"><a href="#多次声明" class="headerlink" title="多次声明"></a>多次声明</h3><p>当使用var时，可以根据需要多次声明相同名称的变量，但是let不能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合法</span></span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&#x27;Chris&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> myName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非法</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&#x27;Chris&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合法</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&#x27;Chris&#x27;</span>;</span><br><span class="line">myName = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>var声明的变量只能是全局或者整个函数块，而let声明的变量具有块级作用域</p>
<h3 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h3><p>let是es6中的新概念，应该尽量使用let去替代var，除非业务场景要求适配IE11以下的浏览器。</p>
<h2 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型:"></a>基本数据类型:</h3><ol>
<li>布尔值（Boolean），有2个值分别是：true 和 false</li>
<li>数字（Number），整数或浮点数，例如： 42 或者 3.14159</li>
<li>字符串（String），字符串是一串表示文本值的字符序列，例如：”Howdy” </li>
<li>符号（Symbol） ( 在 ECMAScript 6 中新添加的类型)，一种实例是唯一且不可改变的数据类型</li>
<li>null ， 一个表明 null 值的特殊关键字。 JavaScript 是大小写敏感的，因此 null 与 Null、NULL或变体完全不同。</li>
<li>undefined ，和 null 一样是一个特殊的关键字，undefined 表示变量未赋值时的属性。<h3 id="对象类型（Object）"><a href="#对象类型（Object）" class="headerlink" title="对象类型（Object）"></a>对象类型（Object）</h3></li>
<li>Function（函数）</li>
<li>Array （数组）</li>
<li>Date（日期）</li>
<li>RegExp（正则表达式）</li>
</ol>
<h2 id="ReferenceError-undefined-Null-NaN区分"><a href="#ReferenceError-undefined-Null-NaN区分" class="headerlink" title="ReferenceError, undefined, Null, NaN区分"></a>ReferenceError, undefined, Null, NaN区分</h2><h3 id="ReferenceError"><a href="#ReferenceError" class="headerlink" title="ReferenceError"></a>ReferenceError</h3><p>访问一个未声明的变量，则怕抛出引用错误异常ReferenceError</p>
<h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>变量只声明未初始化，则其值为undefined，是一个预定义的全局变量</p>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>用来描述“空值”，是一个特殊的对象，含义是“没有对象”，typeof(null)返回object</p>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>数值类型环境中 undefined 值会被转换为 NaN</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a;</span><br><span class="line">a + 2;    &#x2F;&#x2F; 计算为 NaN</span><br></pre></td></tr></table></figure>
<h3 id="关于undefined和null区分的终极解释"><a href="#关于undefined和null区分的终极解释" class="headerlink" title="关于undefined和null区分的终极解释"></a>关于undefined和null区分的终极解释</h3><p>undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，而当需要释放一个对象时，直接赋值为 null 即可。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title>js基础知识复习2——面向对象</title>
    <url>/2021/05/18/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A02%E2%80%94%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="es6中面向对象基础知识复习"><a href="#es6中面向对象基础知识复习" class="headerlink" title="es6中面向对象基础知识复习"></a>es6中面向对象基础知识复习</h1><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过预先声明字段，类定义变得更加自我记录，并且字段始终存在</span></span><br><span class="line">    <span class="comment">//public字段声明</span></span><br><span class="line">    name = <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line">    age = <span class="number">18</span>;</span><br><span class="line">    <span class="comment">//private字段声明</span></span><br><span class="line">    #sex=<span class="string">&#x27;female&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age, sex</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//构造方法中的this是 当前实例对象</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.#sex = sex;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//一般方法</span></span><br><span class="line">    <span class="comment">//方法放在了原型对象上,供实例使用</span></span><br><span class="line">    <span class="comment">//通过实例调用方法时，this就是当前调用方法的实例</span></span><br><span class="line">    <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`我叫<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>，我的年龄是<span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> makes a noise.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用超类构造函数并传入name参数</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法重写</span></span><br><span class="line">    <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> barks.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> Dog(<span class="string">&#x27;Dog1&#x27;</span>);</span><br><span class="line">d.speak();<span class="comment">// &#x27;Dog1 barks.&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="react中类式组件方法的this指针丢失问题"><a href="#react中类式组件方法的this指针丢失问题" class="headerlink" title="react中类式组件方法的this指针丢失问题"></a>react中类式组件方法的this指针丢失问题</h2><p>对于react，类式组件默认开启了严格模式，类中定义的方法通常作为浏览器事件的回调，不是通过该类的实例对象调用的，因此会存在this指针丢失的问题。</p>
<p>render方法和生命周期钩子除外，因为这是react底层通过创建实例调用的。只有一般方法会出现this指针丢失问题。</p>
<p>可以通过定义箭头函数的办法来解决该问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化状态</span></span><br><span class="line">    state = &#123; <span class="attr">isHot</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    <span class="comment">//自定义方法 使用赋值箭头函数解决this丢失</span></span><br><span class="line">    changeWeather = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123; <span class="attr">isHot</span>: !<span class="built_in">this</span>.state.isHot &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误示例</span></span><br><span class="line">    <span class="comment">// changeWeather()&#123;</span></span><br><span class="line">    <span class="comment">//     this.setState(&#123; isHot: !this.state.isHot &#125;)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>前端</category>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title>js基础知识复习3——Array常用的函数式API</title>
    <url>/2021/05/19/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A03%E2%80%94%E2%80%94Array%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8FAPI/</url>
    <content><![CDATA[<h1 id="Array常用的函数式API"><a href="#Array常用的函数式API" class="headerlink" title="Array常用的函数式API"></a>Array常用的函数式API</h1><p>本文总结了js的Array对象的最常用的四个函数式方法（forEach, map, filter, reduce）的用法，更多方法可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array">MDN文档</a>。</p>
<h2 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h2><p>为数组中的每个元素执行一次回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>];</span><br><span class="line">array1.forEach(<span class="function">(<span class="params">item, index</span>)=&gt;</span>&#123;</span><br><span class="line">    item = item * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(item);<span class="comment">//[2, 8, 18, 32]</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array1); <span class="comment">//[1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure>

<h2 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h2><p>返回一个由回调函数的返回值组成的新数组。常用作对象数组的批量修改，react中list的循环渲染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>];</span><br><span class="line"><span class="keyword">const</span> array2 = array1.map(<span class="function">(<span class="params">currentValue, index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentValue*<span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array2); <span class="comment">//[2, 8, 18, 32]</span></span><br></pre></td></tr></table></figure>

<h2 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h2><p>将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。常用作对象数组的删除操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>];</span><br><span class="line"><span class="keyword">const</span> array2 = array1.filter(<span class="function">(<span class="params">currentValue, index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentValue%<span class="number">2</span>===<span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array2); <span class="comment">//[4, 16]</span></span><br></pre></td></tr></table></figure>

<h2 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a>Array.prototype.reduce()</h2><p>从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。常用作数组的统计。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>];</span><br><span class="line"><span class="keyword">let</span> initAccumulator = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> result = array1.reduce(<span class="function">(<span class="params">accumulator, currentValue, index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accumulator += currentValue%<span class="number">2</span>===<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">&#125;, initAccumulator);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title>js基础知识复习4——异步编程</title>
    <url>/2021/05/19/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A04%E2%80%94%E2%80%94%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="js异步编程相关知识点总结"><a href="#js异步编程相关知识点总结" class="headerlink" title="js异步编程相关知识点总结"></a>js异步编程相关知识点总结</h1><p>本文主要介绍了为什么需要异步，异步和同步的区别，<br>以及js中常用的异步编程的方式：callback，Promise，async/await</p>
<h2 id="为什么需要异步"><a href="#为什么需要异步" class="headerlink" title="为什么需要异步"></a>为什么需要异步</h2><p>对于耗时任务（如ajax请求），代码阻塞、等待结果再去执行后续代码，用户在等待中消耗了对于产品的耐心，CPU在等待中也浪费了计算资源。  </p>
<p>如果可以将耗时操作放于后台等待，继续执行剩余代码，等到耗时操作结束（如ajax相应返回时），再去对结果进行处理，就极大程度上增强了用户体验，优化了软件本身。这就是所谓的异步编程。    </p>
<p>传统意义上js是单线程的，无法通过多线程编程、协程等常用的并发策略实现异步编程。后来WebWorks的出现一定程度上帮助解决了异步的问题，但是由于其本身巨大的局限性，如不能访问 DOM，只能做一些计算任务，逐渐在前端开发中被淘汰。</p>
<h2 id="异步和同步的区别"><a href="#异步和同步的区别" class="headerlink" title="异步和同步的区别"></a>异步和同步的区别</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="string">&#x27;You clicked me!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> pElem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">  pElem.textContent = <span class="string">&#x27;This is a newly-added paragraph.&#x27;</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(pElem);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>点击按钮，弹出alert之后，主线程被阻塞，后续的创建节点渲染数据等操作再alert任务处理完成之前不会执行。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="string">&#x27;You clicked me!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pElem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">pElem.textContent = <span class="string">&#x27;This is a newly-added paragraph.&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(pElem);</span><br></pre></td></tr></table></figure>
<p>此时alert语句写于btn的click事件的回调函数中，属于异步任务，而创建节点渲染数据会按照顺序在回调函数<strong>设置</strong>完后直接执行，直到用户点击btn时才会<strong>触发</strong>回调函数</p>
<h2 id="callback方式"><a href="#callback方式" class="headerlink" title="callback方式"></a>callback方式</h2><h3 id="callback的示例"><a href="#callback的示例" class="headerlink" title="callback的示例"></a>callback的示例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  alert(<span class="string">&#x27;You clicked me!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>箭头函数即是btn的click事件的回调函数  </p>
<h3 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h3><p>以购买披萨作为类比。为了使订单成功，必须按顺序执行，不按顺序执行或上一步没完成就执行下一步是不会成功的：</p>
<ol>
<li>选择配料。如果优柔寡断，这可能需要一段时间，如果无法下定决心或者决定换咖喱，可能会失败。  </li>
<li>下订单。返回比萨饼可能需要一段时间，如果餐厅没有烹饪所需的配料，可能会失败。  </li>
<li>然后吃披萨。如果你忘记了自己的钱包，那么这又可能会失败，因为无法支付比萨饼的费用。</li>
</ol>
<p>代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chooseToppings(<span class="function"><span class="keyword">function</span>(<span class="params">toppings</span>) </span>&#123;</span><br><span class="line">  placeOrder(toppings, <span class="function"><span class="keyword">function</span>(<span class="params">order</span>) </span>&#123;</span><br><span class="line">    collectOrder(order, <span class="function"><span class="keyword">function</span>(<span class="params">pizza</span>) </span>&#123;</span><br><span class="line">      eatPizza(pizza);</span><br><span class="line">    &#125;, failureCallback);</span><br><span class="line">  &#125;, failureCallback);</span><br><span class="line">&#125;, failureCallback);</span><br></pre></td></tr></table></figure>

<p>为了解决“回调地狱”的问题，Promise应运而生。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h3 id="对上面进行改良"><a href="#对上面进行改良" class="headerlink" title="对上面进行改良"></a>对上面进行改良</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chooseToppings()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">toppings</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> placeOrder(toppings);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">order</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> collectOrder(order);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">pizza</span>) </span>&#123;</span><br><span class="line">  eatPizza(pizza);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此时只需要一个catch来处理所有的错误，并通过then来链接一个接一个的异步操作，每一个then将返回一个新的promise作为后续的参数输入。</p>
<h3 id="使用箭头函数进一步改良"><a href="#使用箭头函数进一步改良" class="headerlink" title="使用箭头函数进一步改良"></a>使用箭头函数进一步改良</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chooseToppings()</span><br><span class="line">.then(<span class="function"><span class="params">toppings</span> =&gt;</span> placeOrder(toppings))</span><br><span class="line">.then(<span class="function"><span class="params">order</span> =&gt;</span> collectOrder(order))</span><br><span class="line">.then(<span class="function"><span class="params">pizza</span> =&gt;</span> eatPizza(pizza))</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>async和await关键字是es6新增内容，它们俩是基于promises的语法糖，使得异步代码更容易编写和阅读。</p>
<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async关键字用来放在函数的声明之前，使其成为async function，只有在async function中才可以使用await关键字</p>
<h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>await关键字只能在async function里面起作用。await可以放在任何异步的，基于promise的函数之前，当耗时操作进行时，它会暂停到该行上，直到promise完成返回结果值。暂停的同时，其他代码是可以执行的。</p>
<h3 id="async和await相比于常规的Promise"><a href="#async和await相比于常规的Promise" class="headerlink" title="async和await相比于常规的Promise"></a>async和await相比于常规的Promise</h3><p>常规的Promise需要写大量的<code>.then()</code>，而async和await则可以通过同步的方式编写异步代码块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常规Promise</span></span><br><span class="line">fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> response.blob())</span><br><span class="line">.then(<span class="function"><span class="params">myBlob</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + e.message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用async/await</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">&#x27;coffee.jpg&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> myBlob = <span class="keyword">await</span> response.blob();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob);</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  image.src = objectURL;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch()</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;There has been a problem with your fetch operation: &#x27;</span> + e.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title>js基础知识复习5——展开运算符</title>
    <url>/2021/05/20/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A05%E2%80%94%E2%80%94%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="js展开运算符"><a href="#js展开运算符" class="headerlink" title="js展开运算符"></a>js展开运算符</h1><p><code>...</code>为es6中新增的展开运算符，主要有以下使用场景：  </p>
<ol>
<li>函数调用时处理参数</li>
<li>函数定义形参时作不定参数</li>
<li>数组快捷操作</li>
<li>对象快捷操作</li>
</ol>
<h2 id="函数调用时处理参数（替代apply方法）"><a href="#函数调用时处理参数（替代apply方法）" class="headerlink" title="函数调用时处理参数（替代apply方法）"></a>函数调用时处理参数（替代apply方法）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFun</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line">addFun(args[<span class="number">0</span>], args[<span class="number">1</span>], args[<span class="number">2</span>])</span><br><span class="line">addFun.apply(<span class="literal">null</span>, args);</span><br><span class="line">addFun(...args);<span class="comment">//使用展开运算符</span></span><br></pre></td></tr></table></figure>

<h2 id="函数定义设置不定参数"><a href="#函数定义设置不定参数" class="headerlink" title="函数定义设置不定参数"></a>函数定义设置不定参数</h2><p>此时<code>...</code>其实是rest运算符，可以理解为与扩展运算符是相反的，扩展运算符是“展开”，rest运算符是“合并”</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> demoFun = <span class="function"><span class="keyword">function</span>(<span class="params">argA, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(argA);</span><br><span class="line">    <span class="built_in">console</span>.log(args)</span><br><span class="line">&#125;</span><br><span class="line">demoFun(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>

<h2 id="数组快捷操作"><a href="#数组快捷操作" class="headerlink" title="数组快捷操作"></a>数组快捷操作</h2><h3 id="数组连接"><a href="#数组连接" class="headerlink" title="数组连接"></a>数组连接</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5连接</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6连接</span></span><br><span class="line">arr1.push(...arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h3 id="合并数组"><a href="#合并数组" class="headerlink" title="合并数组"></a>合并数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5合并</span></span><br><span class="line"><span class="keyword">let</span> arr3 = arr1.concat(arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr3) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6合并</span></span><br><span class="line"><span class="keyword">let</span> arr3 = [...arr1, ...arr2]</span><br><span class="line"><span class="built_in">console</span>.log(arr3) <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h3 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1];</span><br><span class="line"><span class="built_in">console</span>.log(arr1 === arr2) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">arr2.push(<span class="number">4</span>); <span class="comment">// 修改arr2，不会影响arr1的值</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h2 id="对象快捷操作"><a href="#对象快捷操作" class="headerlink" title="对象快捷操作"></a>对象快捷操作</h2><h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;...obj1&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">obj2.c = <span class="number">3</span>; <span class="comment">// 修改obj2不会影响obj1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123;a: 1, b: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;a: 1, b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="对象更新"><a href="#对象更新" class="headerlink" title="对象更新"></a>对象更新</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;...todo1, <span class="attr">b</span>:<span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">//&#123; a: 1, b: 3 &#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>基础知识</category>
      </categories>
  </entry>
  <entry>
    <title>Axios的Delete方法踩坑记实</title>
    <url>/2021/07/31/%E5%89%8D%E7%AB%AF/%E7%BB%8F%E9%AA%8C%E8%AE%B0%E5%BD%95/Axios%E7%9A%84Delete%E6%96%B9%E6%B3%95%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%AE%9E/</url>
    <content><![CDATA[<p>最近做项目，delete方法的请求体body里面的数据，发送请求后端查看请求body为空，也没有任何报错，查阅相关资料后得知axios的delete请求方法的封装和其他类型不一样导致的。</p>
<h2 id="POST-PUT方法"><a href="#POST-PUT方法" class="headerlink" title="POST, PUT方法"></a>POST, PUT方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(<span class="string">`<span class="subst">$&#123;url&#125;</span>`</span>,&#123;<span class="string">&#x27;id&#x27;</span>:id, <span class="string">&#x27;name&#x27;</span>:name&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure>
<p>对于POST和PUT，axios的封装是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.post(url, data, config)</span><br><span class="line">axios.put(url, data, config)</span><br></pre></td></tr></table></figure>

<h2 id="Delete方法"><a href="#Delete方法" class="headerlink" title="Delete方法"></a>Delete方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.delete(<span class="string">`<span class="subst">$&#123;url&#125;</span>`</span>,&#123;<span class="string">&#x27;data&#x27;</span>:dataObj&#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;...&#125;)</span><br></pre></td></tr></table></figure>
<p>对于POST和PUT，axios的封装是</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.delete(url, config)</span><br></pre></td></tr></table></figure>
<p>因此应该在config对象中手动设置data字段，对应内容为要传递的对象即可</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>经验记录</category>
      </categories>
  </entry>
  <entry>
    <title>前端unix时间戳转为字符串</title>
    <url>/2021/05/04/%E5%89%8D%E7%AB%AF/%E7%BB%8F%E9%AA%8C%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AFunix%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>unix时间戳是从1970年1月1日（UTC/GMT的午夜）开始所经过的秒数，不考虑闰秒。</p>
<p>js中关于时间戳转字符串，主要是通过js Date对象的原生api来进行操作。</p>
<p>有时候时间戳需要乘1000，有时候不需要。这是因为unix时间戳以秒(s)为单位进行计时，数据长度为10位，而js以毫秒(ms)为单位进行计时，数据长度为13位。因此只需要根据时间戳的位数来确定是否要乘1000.</p>
<p>本文给出js中获取时间戳以及将时间戳转为普通格式时间字符串的常用方法。</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取时间戳</span></span><br><span class="line"><span class="keyword">let</span> timestamp = <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">//s</span></span><br><span class="line"><span class="keyword">let</span> timestamp = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime(); <span class="comment">//ms</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将时间戳转为时间字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//toJSON格林威治时间方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timetrans</span>(<span class="params">timestamp</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dateObj = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    dateObj.setTime(timestamp *<span class="number">1</span> <span class="number">000</span> + <span class="number">8</span> * <span class="number">3600</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> dateObj.toJSON().substr(<span class="number">0</span>, <span class="number">19</span>).replace(<span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常规方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timetrans</span>(<span class="params">date</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(date*<span class="number">1000</span>);<span class="comment">//如果date为13位不需要乘1000</span></span><br><span class="line">    <span class="keyword">let</span> Y = date.getFullYear() + <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> M = (date.getMonth()+<span class="number">1</span> &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span>+(date.getMonth()+<span class="number">1</span>) : date.getMonth()+<span class="number">1</span>) + <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> D = (date.getDate() &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + (date.getDate()) : date.getDate()) + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> h = (date.getHours() &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + date.getHours() : date.getHours()) + <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> m = (date.getMinutes() &lt;<span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + date.getMinutes() : date.getMinutes()) + <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> s = (date.getSeconds() &lt;<span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + date.getSeconds() : date.getSeconds());</span><br><span class="line">    <span class="keyword">return</span> Y+M+D+h+m+s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>经验记录</category>
      </categories>
  </entry>
  <entry>
    <title>前端全局修改滚动条样式</title>
    <url>/2021/05/04/%E5%89%8D%E7%AB%AF/%E7%BB%8F%E9%AA%8C%E8%AE%B0%E5%BD%95/%E5%89%8D%E7%AB%AF%E5%85%A8%E5%B1%80%E4%BF%AE%E6%94%B9%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p>由于浏览器默认的滚动条样式不太现代，在网上看了很多条关于滚动条美化的博客。找了一种最方便的，记录一下。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 滚动条宽度 */</span></span><br><span class="line">::-webkit-scrollbar &#123;</span><br><span class="line">    width: <span class="number">7px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/* 滚动条的滑块 */</span></span><br><span class="line">::-webkit-scrollbar-thumb &#123;</span><br><span class="line">background-color: $border-<span class="number">3</span>;</span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>经验记录</category>
      </categories>
  </entry>
</search>
